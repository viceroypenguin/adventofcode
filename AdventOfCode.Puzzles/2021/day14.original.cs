namespace AdventOfCode.Puzzles._2021;

[Puzzle(2021, 14, CodeType.Original)]
public class Day_14_Original : IPuzzle
{
	public (string part1, string part2) Solve(PuzzleInput input)
	{
		var part1 = DoPartA(input.Lines);
		var part2 = DoPartB(input.Lines);

		return (part1, part2);
	}

	private string DoPartA(string[] lines)
	{
		// starting polymer
		var polymer = lines[0].ToList();
		// parse the rest of the lines as instructinos
		var instructions = lines
			.Skip(1)
			.Where(x => !string.IsNullOrWhiteSpace(x))
			.Select(x => x.Split(" -> "))
			// instruction is a translation for two chars to the first
			// two chars of the replacement. third char will be provided
			// by the next pair
			.Select(x => (old: x[0].ToList(), @new: new[] { x[0][0], x[1][0], }))
			.ToList();

		// run an insertion process
		List<char> insert(List<char> polymer) =>
			polymer
				// look at every pair of chars
				// last char will be paired w/ a '\0'
				.Lead(1, (a, b) =>
				{
					// if we're on the last char, just return the first char
					if (b == default) return new[] { a, };
					// find the replacement instruction
					var (_, @new) = instructions
						.FirstOrDefault(x => x.old[0] == a && x.old[1] == b);
					// return the replacement, or just the first char if there isn't one
					return @new ?? new[] { a, };
				})
				// at this point, we have a bunch of two-char arrays
				// flatten them back into a single long array
				.SelectMany(x => x)
				.ToList();

		// run the insertion ten times
		for (int i = 0; i < 10; i++)
			polymer = insert(polymer);

		var elements = polymer
			// group the list by element
			// and count how many of each
			.GroupBy(x => x, (c, g) => (c, cnt: g.Count()))
			// sort by the count
			.OrderBy(x => x.cnt)
			.ToList();

		// most is the last entry, least is the first entry
		// difference and print
		return (elements[^1].cnt - elements[0].cnt).ToString();
	}

	private string DoPartB(string[] lines)
	{
		// starting polymer
		// polymer is now a list of two char keys, and a count of how many instances
		var polymer = lines[0]
			// pair up the characters
			.Window(2)
			// and save the keys, with a count of 1 to start
			.Select(x => (key: string.Join("", x), cnt: 1L))
			.ToList();

		var instructions = lines
			.Skip(1)
			.Where(x => !string.IsNullOrWhiteSpace(x))
			.Select(x => x.Split(" -> "))
			// this time, we're going to use a dictionary for fast lookup
			// dict value is the pair of keys generated by the triplet
			// expressed by the instruction
			.ToDictionary(
				x => x[0],
				x => new[]
				{
					string.Join("", x[0][0], x[1][0]),
					string.Join("", x[1][0], x[0][1]),
				});

		// run an insertion process
		List<(string key, long cnt)> insert(List<(string key, long cnt)> polymer) =>
			polymer
				// each replacement will return multiple entries
				// so flatten them back out to start with
				// start by finding the replacement values
				// using the key
				.SelectMany(x => instructions[x.key]
					// count how many of the replacement values
					// according to how many we started with
					.Select(y => (key: y, x.cnt)))
				// we now have multiple instances of each key, 
				// each with it's own count
				// group them, and sum the count to get a single list
				// with a full count
				.GroupBy(x => x.key, (key, g) => (key, g.Sum(x => x.cnt)))
				.ToList();

		// run the process 40 times
		for (int i = 0; i < 40; i++)
			polymer = insert(polymer);

		var elements = polymer
			// we're only going to count the first char of each
			// group, so we need to add the last char of the polymer
			// thankfully with insertion, the last char doesn't change
			// so we can just grab it from the beginning
			.Append((lines[0][^1..], 1))
			// don't care about the second char in the key, since it
			// is duplicated by the next key; so grab all of the first
			// chars in each key, group them, and sum the count to get
			// a single list of elements and counts
			.GroupBy(x => x.key[0], (c, g) => (c, cnt: g.Sum(x => x.cnt)))
			// sort by the count
			.OrderBy(x => x.cnt)
			.ToList();

		// most is the last entry, least is the first entry
		// difference and print
		return (elements[^1].cnt - elements[0].cnt).ToString();
	}
}
